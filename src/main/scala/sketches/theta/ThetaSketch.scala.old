package com.ber2.spark.sketches.theta

import scala.math.{round, log, pow, min, max}
import scala.util.hashing.MurmurHash3

import java.nio.ByteBuffer

import Constants.{K, M}

case class ThetaSketch(numZeros: Long, hashValues: Array[Long]) {
  def update(s: String): ThetaSketch = {
    val newHashes = hashValues.clone

    val hash: Int = MurmurHash3.bytesHash(s.getBytes)

    val i = hash & ((1 << K) - 1)
    val r = (hash >>> K) | (1L << 63 - K)
    
    newHashes(i) = min(r, newHashes(i))
    val newZeros = 
      if (r == 0L) numZeros + 1L
      else numZeros

    ThetaSketch(numZeros, newHashes)
  }

  def getEstimate: Long = {
    val theta = getTheta
    if (theta <= 1.0 / (1L << K)) numZeros
    else round(1L / theta * (1L << 32))
  }

  def union(other: ThetaSketch): ThetaSketch = {
    val newHashes = hashValues
      .zip(other.hashValues)
      .map { case (a, b) =>
        min(a, b)
      }

    ThetaSketch(numZeros + other.numZeros, newHashes)
  }

  def intersection(other: ThetaSketch): ThetaSketch = ???//{
    //val result = sketch
      //.zip(other.sketch)
      //.map { case (a, b) =>
        //if (a > 0 && b > 0) max(a, b).toShort
        //else 0.toShort
      //}

    //ThetaSketch(result)
  //}

  def aNotB(other: ThetaSketch): ThetaSketch = ???//{
    //val result = sketch
      //.zip(other.sketch)
      //.map { case (a, b) =>
        //if (a > b) (a - b).toShort
        //else 0.toShort
      //}

    //ThetaSketch(result)
  //}

  def serialized: SerializedThetaSketch = {
    val bb = ByteBuffer.allocate(8 + 8 * M)
    bb.putLong(numZeros)
    hashValues.foreach { x => bb.putLong(x) }
    SerializedThetaSketch(bb.array)
  }

  private def getTheta: Double = {
    val numItems = 1L << K

    if (numZeros == 0L) 1.0
    else {
      val estimate = numItems.toDouble
      if (estimate <= 5.0 * numItems) numZeros.toDouble
      else {
        val theta = numItems.toDouble / estimate
        val delta = 1.0 - numZeros.toDouble / numItems.toDouble
        theta * delta * delta * delta
      }
    }
  }

  //private def rho(d: Int): Short = {
    //val rho = Integer.numberOfTrailingZeros(Integer.rotateLeft(d, K - 1))

    //if (rho <= K) rho.toShort
    //else 0
  //}

  //private def rhoInv(r: Short): Int = 1 << r
  //private def alpha(r: Double): Double = {
    //val a = 1.0 / (2 - r)
    //val b = (1 - pow(2, -r)) / (2 - pow(2, -r))

    //if (r <= 1) a
    //else if (r <= 32) b
    //else 1 / (1.38 * pow(r, 0.5) + 0.5)
  //}
}

object ThetaSketch {
  def apply(): ThetaSketch = {
    val hashValues = Array.fill[Long](1 << K)(Long.MaxValue)
    ThetaSketch(0L, hashValues)
  }

  def fromStrings(values: Seq[String]): ThetaSketch =
    values.foldLeft(ThetaSketch()) { (th: ThetaSketch, s: String) =>
      th.update(s)
    }
}
